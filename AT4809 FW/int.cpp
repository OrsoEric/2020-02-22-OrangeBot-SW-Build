/****************************************************************************
**	INCLUDE
****************************************************************************/

//type definition using the bit width and signedness
#include <stdint.h>
//define the ISR routune, ISR vector, and the sei() cli() function
#include <avr/interrupt.h>
//name all the register and bit
#include <avr/io.h>

//General purpose macros
#include "at_utils.h"
//AT4809 PORT macros definitions
#include "at4809_port.h"

#include "global.h"

/****************************************************************************
**GLOBAL VARS
****************************************************************************/

/****************************************************************************
** INTERRUPT SERVICE ROUTINE
*****************************************************************************
**	In the AT4809 ISR flags have to be cleared manually
****************************************************************************/

/****************************************************************************
**	RTC Periodic Interrupt
*****************************************************************************
**	Periodic interrupt generated by the RTC from it's independent clock source
**		system tick
**	Fastest tick for general fast operations
**		control system
**	Issue the execution of the control system for the motors
**		slow tick
**	Issue a slow tick meant for non time critical communication and housekeeping tasks
****************************************************************************/

ISR( RTC_PIT_vect )
{	
	//----------------------------------------------------------------
	//	VARS
	//----------------------------------------------------------------

	//Prescaler for slow tick
	static uint8_t pre_slow = 0;
	static uint8_t pre_ctrl_sys = 0;

	//----------------------------------------------------------------
	//	INIT
	//----------------------------------------------------------------

	//----------------------------------------------------------------
	//	BODY
	//----------------------------------------------------------------	
	
		//----------------------------------------------------------------
		//	FAST CONTROL SYSTEM TICK
		//----------------------------------------------------------------	

	//Detect if a control system execution is still pending
	if (g_isr_flags.ctrl_fast_updt == true)
	{
		//Report pending
		g_isr_flags.err_pending = true;
	}
	//Fast 
	g_isr_flags.ctrl_fast_updt = true;
	
		//----------------------------------------------------------------
		//	SLOW CONTROL SYSTEM TICK
		//----------------------------------------------------------------
	
	//If: control system is executed every fast tick
	if (Prescaler::TOP_SLOW_CTRL_SYS == 0)
	{
		//Detect if a control system execution is still pending
		if (g_isr_flags.ctrl_slow_updt == true)
		{
			//Report pending
			g_isr_flags.err_pending = true;
		}
		
		//Issue Control System Execution
		g_isr_flags.ctrl_slow_updt = true;
	}
	//If: 
	else
	{		
		//If: Control System Tick Tick
		if (pre_ctrl_sys == 0)
		{
			//Detect if a control system execution is still pending
			if (g_isr_flags.ctrl_slow_updt == true)
			{
				//Report pending
				g_isr_flags.err_pending = true;
			}
			
			//Issue Control System Execution
			g_isr_flags.ctrl_slow_updt = true;
		}
		pre_ctrl_sys = AT_TOP_INC( pre_ctrl_sys, Prescaler::TOP_SLOW_CTRL_SYS );
	}
	
		//----------------------------------------------------------------
		//	SLOW TICK
		//----------------------------------------------------------------
	
	//If: Slow Tick
	if (pre_slow == 0)
	{
		//Issue a slow tick
		g_isr_flags.slow_tick = true;
	}
	pre_slow = AT_TOP_INC( pre_slow, Prescaler::TOP_SLOW_TICK );
	
	//----------------------------------------------------------------
	//	RETURN
	//----------------------------------------------------------------
	
	//Manually clear the interrupt flag
	RTC.PITINTFLAGS = RTC_PI_bm;
}

/****************************************************************************
**	USART3 RX Interrupt
*****************************************************************************
**	
****************************************************************************/

ISR( USART3_RXC_vect )
{
	//----------------------------------------------------------------
	//	VARS
	//----------------------------------------------------------------
	
	//Temp var
	uint8_t rx_data_tmp;
	
	//----------------------------------------------------------------
	//	INIT
	//----------------------------------------------------------------
	
	//----------------------------------------------------------------
	//	BODY
	//----------------------------------------------------------------
	
	//Fetch the data and clear the interrupt flag
	rx_data_tmp = USART3.RXDATAL;
	
	if (AT_BUF_NUMELEM(rpi_rx_buf)>=(RPI_RX_BUF_SIZE-1))
	{
		//An overflow occurred on the RX buffer. Ask main to handle it.
		g_isr_flags.rx_buf_ovf = true;
	}
	else
	{
		//Push byte into RX buffer for processing
		AT_BUF_PUSH_SAFER( rpi_rx_buf, rx_data_tmp );	
	}
	
	//----------------------------------------------------------------
	//	RETURN
	//----------------------------------------------------------------	
	
}	//End ISR: USART3_RXC_vect

/****************************************************************************
**  ISR
**  PORTC_PORT_vect
****************************************************************************/
//! @brief 
//! @details
//! Any edge on any pin in PORTC will trigger this interrupt
//! Call the quad channel encoder decoder routine
//! Do it as call because the routine can be called from elsewhere
/***************************************************************************/

ISR( PORTC_PORT_vect )
{
	//----------------------------------------------------------------
	//	BODY
	//----------------------------------------------------------------
	
	//quad channel encoder decoder routine
	quad_encoder_decoder( PORTC.IN );
	
	//----------------------------------------------------------------
	//	RETURN
	//----------------------------------------------------------------
	
	//Clear the Interrupt Flags of PORTC
	PORTC.INTFLAGS = (uint8_t)0xff;
} //End ISR: PORTC_PORT_vect
